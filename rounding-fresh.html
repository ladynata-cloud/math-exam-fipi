<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–¢—Ä–µ–Ω–∞–∂—ë—Ä –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è (fresh v4)</title>

  <!-- –í–ê–ñ–ù–û: –Ω–µ –ø–æ–¥–∫–ª—é—á–∞–µ–º style.css, —á—Ç–æ–±—ã –æ–Ω –Ω–µ –ª–æ–º–∞–ª —Ä–∞–∑–º–µ—Ä—ã/—Ü–≤–µ—Ç–∞/—à—Ä–∏—Ñ—Ç—ã —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞ -->
  <link rel="stylesheet" href="rounding-fresh.css?v=4" />
</head>
<body>
  <main class="rf">
    <header class="rf__header">
      <h1 class="rf__title">–¢—Ä–µ–Ω–∞–∂—ë—Ä –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è <span class="rf__badge">v4</span></h1>
      <p class="rf__subtitle">–£–∫–∞–∑–∞—Ç–µ–ª—å —Ä–∞–∑—Ä—è–¥–æ–≤ + –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –Ω—É–ª–µ–π (–∞–≤—Ç–æ–Ω–æ–º–Ω—ã–µ —Å—Ç–∏–ª–∏).</p>
      <p class="rf__back"><a href="index.html">‚Üê –ù–∞ –≥–ª–∞–≤–Ω—É—é</a></p>
    </header>

    <section class="rf__panel">
      <div class="rf__row">
        <label class="rf__label" for="targetSelect">–û–∫—Ä—É–≥–ª—è–µ–º:</label>
        <select id="targetSelect" class="rf__select"></select>

        <label class="rf__label" for="levelSelect">–£—Ä–æ–≤–µ–Ω—å:</label>
        <select id="levelSelect" class="rf__select rf__select--small">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>

        <label class="rf__toggle" title="–ò–Ω–æ–≥–¥–∞ –±—É–¥—É—Ç –∑–∞–¥–∞—á–∏ ‚Äú–∏–∑ –∂–∏–∑–Ω–∏‚Äù">
          <input type="checkbox" id="appliedToggle" checked />
          <span>–ü—Ä–∏–∫–ª–∞–¥–Ω—ã–µ</span>
        </label>

        <button id="newBtn" class="rf__btn" type="button">–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä</button>
      </div>

      <div class="rf__row rf__row--series">
        <div class="rf__seriesLeft">
          <span class="rf__label">–°–µ—Ä–∏—è:</span>
          <input id="seriesSize" class="rf__input rf__input--tiny" type="number" min="5" max="30" value="10" />
          <button id="startSeriesBtn" class="rf__btn rf__btn--primary" type="button">–°—Ç–∞—Ä—Ç</button>
          <button id="stopSeriesBtn" class="rf__btn rf__btn--ghost" type="button" style="display:none;">–°–±—Ä–æ—Å</button>
        </div>

        <div class="rf__seriesRight">
          <div id="seriesText" class="rf__seriesText">–°–µ—Ä–∏—è –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞</div>
          <div class="rf__bar" aria-hidden="true">
            <div id="seriesBarFill" class="rf__barFill" style="width:0%"></div>
          </div>
        </div>
      </div>

      <div class="rf__stats">
        <div class="rf__stat">
          <div class="rf__statValue" id="statSolved">0</div>
          <div class="rf__statLabel">–ü—Ä–æ–≤–µ—Ä–æ–∫</div>
        </div>
        <div class="rf__stat">
          <div class="rf__statValue" id="statCorrect">0</div>
          <div class="rf__statLabel">–í–µ—Ä–Ω–æ</div>
        </div>
        <div class="rf__stat">
          <div class="rf__statValue" id="statAccuracy">0%</div>
          <div class="rf__statLabel">–¢–æ—á–Ω–æ—Å—Ç—å</div>
        </div>
        <div class="rf__stat">
          <div class="rf__statValue" id="statStreak">0</div>
          <div class="rf__statLabel">–°–µ—Ä–∏—è –≤–µ—Ä–Ω—ã—Ö</div>
        </div>
      </div>
    </section>

    <section class="rf__card">
      <div class="rf__taskLabel">–ó–∞–¥–∞–Ω–∏–µ</div>
      <div id="taskText" class="rf__taskText">–ù–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª (–∏–ª–∏ ¬´–°—Ç–∞—Ä—Ç¬ª –¥–ª—è —Å–µ—Ä–∏–∏).</div>

      <div id="guide" class="rf__guide" hidden>
        <div class="rf__guideLabel">–ù–∞ —á—Ç–æ —Å–º–æ—Ç—Ä–∏–º</div>
        <div id="guideDigits" class="rf__guideDigits"></div>
        <div id="guideText" class="rf__guideText"></div>
      </div>

      <div class="rf__answerRow">
        <label class="rf__label" for="answerInput">–û—Ç–≤–µ—Ç:</label>
        <input id="answerInput" class="rf__input" inputmode="decimal" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: 350 –∏–ª–∏ 3,14" />
        <button id="checkBtn" class="rf__btn rf__btn--check" type="button">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="nextBtn" class="rf__btn rf__btn--next" type="button">–î–∞–ª—å—à–µ</button>
      </div>

      <div class="rf__actions">
        <button id="hintBtn" class="rf__btn rf__btn--ghost" type="button">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        <button id="solutionBtn" class="rf__btn rf__btn--ghost" type="button">–†–µ—à–µ–Ω–∏–µ</button>
        <button id="resetProgressBtn" class="rf__btn rf__btn--ghost" type="button">–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å</button>
      </div>

      <div id="message" class="rf__message" aria-live="polite" style="display:none;"></div>
      <div id="solutionBox" class="rf__solution" style="display:none;"></div>

      <div id="storageNote" class="rf__storageNote" style="display:none;">
        –ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è (–±—Ä–∞—É–∑–µ—Ä –∑–∞–ø—Ä–µ—Ç–∏–ª —Ö—Ä–∞–Ω–∏–ª–∏—â–µ). –ù–∏—á–µ–≥–æ —Å—Ç—Ä–∞—à–Ω–æ–≥–æ ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.
      </div>
    </section>

    <details class="rf__rules">
      <summary>–ü—Ä–∞–≤–∏–ª–æ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è (–∫–æ—Ä–æ—Ç–∫–æ)</summary>
      <div class="rf__rulesBody">
        <ol>
          <li>–û–ø—Ä–µ–¥–µ–ª–∏ —Ä–∞–∑—Ä—è–¥, <b>–¥–æ –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–∫—Ä—É–≥–ª—è–µ—à—å</b>.</li>
          <li>–ü–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ —Ü–∏—Ñ—Ä—É <b>—Å–ø—Ä–∞–≤–∞</b> –æ—Ç —ç—Ç–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞.</li>
          <li>–ï—Å–ª–∏ —Å–ø—Ä–∞–≤–∞ <b>0‚Äì4</b> ‚Äî —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º.</li>
          <li>–ï—Å–ª–∏ —Å–ø—Ä–∞–≤–∞ <b>5‚Äì9</b> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä—è–¥ –Ω–∞ 1.</li>
          <li>–î–ª—è —Ü–µ–ª—ã—Ö: —Ü–∏—Ñ—Ä—ã —Å–ø—Ä–∞–≤–∞ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω—É–ª—è–º–∏. –î–ª—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö: –ª–∏—à–Ω–∏–µ –∑–Ω–∞–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º.</li>
        </ol>
      </div>
    </details>
  </main>

<script>
(() => {
  "use strict";

  const BASE_SCALE = 10000;
  const BASE_DECIMALS = 4;
  const STORAGE_KEY = "rounding_fresh_state_v4";
  const CHECK_LOCK_MS = 1200;
  const APPLIED_PROB = 0.22;

  const $ = (id) => document.getElementById(id);

  const el = {
    targetSelect: $("targetSelect"),
    levelSelect: $("levelSelect"),
    appliedToggle: $("appliedToggle"),
    newBtn: $("newBtn"),

    seriesSize: $("seriesSize"),
    startSeriesBtn: $("startSeriesBtn"),
    stopSeriesBtn: $("stopSeriesBtn"),
    seriesText: $("seriesText"),
    seriesBarFill: $("seriesBarFill"),

    statSolved: $("statSolved"),
    statCorrect: $("statCorrect"),
    statAccuracy: $("statAccuracy"),
    statStreak: $("statStreak"),

    taskText: $("taskText"),
    guide: $("guide"),
    guideDigits: $("guideDigits"),
    guideText: $("guideText"),

    answerInput: $("answerInput"),
    checkBtn: $("checkBtn"),
    nextBtn: $("nextBtn"),

    hintBtn: $("hintBtn"),
    solutionBtn: $("solutionBtn"),
    resetProgressBtn: $("resetProgressBtn"),

    message: $("message"),
    solutionBox: $("solutionBox"),
    storageNote: $("storageNote"),
  };

  // storage safe
  const storage = (() => {
    try {
      const t = "__t";
      localStorage.setItem(t, "1");
      localStorage.removeItem(t);
      return localStorage;
    } catch {
      return null;
    }
  })();

  if (!storage) el.storageNote.style.display = "block";

  const safeLoad = () => {
    if (!storage) return null;
    try {
      const raw = storage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  };

  const safeSave = (obj) => {
    if (!storage) return;
    try { storage.setItem(STORAGE_KEY, JSON.stringify(obj)); } catch {}
  };

  const TARGETS = [
    { id: "tens",        label: "–¥–æ –¥–µ—Å—è—Ç–∫–æ–≤",        step: 10,    decimalsAnswer: 0 },
    { id: "hundreds",    label: "–¥–æ —Å–æ—Ç–µ–Ω",          step: 100,   decimalsAnswer: 0 },
    { id: "thousands",   label: "–¥–æ —Ç—ã—Å—è—á",          step: 1000,  decimalsAnswer: 0 },

    { id: "units",       label: "–¥–æ —Ü–µ–ª—ã—Ö",          step: 1,     decimalsAnswer: 0 },

    { id: "tenths",      label: "–¥–æ –¥–µ—Å—è—Ç—ã—Ö",        step: 0.1,   decimalsAnswer: 1 },
    { id: "hundredths",  label: "–¥–æ —Å–æ—Ç—ã—Ö",          step: 0.01,  decimalsAnswer: 2 },
    { id: "thousandths", label: "–¥–æ —Ç—ã—Å—è—á–Ω—ã—Ö",       step: 0.001, decimalsAnswer: 3 },
  ];

  const fillTargetSelect = () => {
    el.targetSelect.innerHTML = "";
    for (const t of TARGETS) {
      const opt = document.createElement("option");
      opt.value = t.id;
      opt.textContent = t.label;
      el.targetSelect.appendChild(opt);
    }
  };

  const getTarget = (id) => TARGETS.find(t => t.id === id) || TARGETS[0];

  let stats = { solved: 0, correct: 0, streak: 0, bestStreak: 0 };
  let series = { active: false, size: 10, index: 0, correct: 0 };
  let current = null;
  let checkLocked = false;

  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  const scaledToStringRu = (scaled, decimals) => {
    const abs = Math.abs(scaled);
    const intPart = Math.floor(abs / BASE_SCALE);
    const frac = abs % BASE_SCALE;
    if (decimals <= 0) return String(intPart);
    const fracStrFull = String(frac).padStart(BASE_DECIMALS, "0");
    return `${intPart},${fracStrFull.slice(0, decimals)}`;
  };

  const normalizeInput = (s) => {
    let t = (s || "").trim().replace(/\s+/g, "").replace(",", ".");
    if (!t) return "";
    if (t[0] === "+") t = t.slice(1);
    if (t[0] === "-") return "NEGATIVE_NOT_ALLOWED";
    if (!/^\d+(\.\d+)?$/.test(t)) return "BAD_FORMAT";
    const parts = t.split(".");
    let intPart = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    if (intPart === "") intPart = "0";
    const fracPart = parts[1] ?? null;
    return fracPart === null ? intPart : (intPart + "." + fracPart);
  };

  const parseToScaled = (inputNorm, allowedDecimals) => {
    const parts = inputNorm.split(".");
    const intVal = parseInt(parts[0], 10);
    if (!Number.isFinite(intVal)) return { ok: false };
    const fracStrRaw = parts[1] || "";

    let extraNonZero = false;
    if (fracStrRaw.length > allowedDecimals) {
      extraNonZero = [...fracStrRaw.slice(allowedDecimals)].some(ch => ch !== "0");
    }

    const fracPadded = (fracStrRaw + "0".repeat(BASE_DECIMALS)).slice(0, BASE_DECIMALS);
    const fracVal = parseInt(fracPadded || "0", 10);
    const scaled = intVal * BASE_SCALE + (Number.isFinite(fracVal) ? fracVal : 0);
    return { ok: true, scaled, extraNonZero };
  };

  const stepToScaled = (step) => Math.round(step * BASE_SCALE);
  const rightPlaceScaled = (stepScaled) => Math.floor(stepScaled / 10);

  const digitAt = (nScaled, placeScaled) => {
    if (placeScaled <= 0) return 0;
    return Math.floor(nScaled / placeScaled) % 10;
  };

  const placeNameRight = (targetId) => ({
    tens: "–µ–¥–∏–Ω–∏—Ü—ã",
    hundreds: "–¥–µ—Å—è—Ç–∫–∏",
    thousands: "—Å–æ—Ç–Ω–∏",
    units: "–¥–µ—Å—è—Ç—ã–µ",
    tenths: "—Å–æ—Ç—ã–µ",
    hundredths: "—Ç—ã—Å—è—á–Ω—ã–µ",
    thousandths: "–¥–µ—Å—è—Ç–∏—Ç—ã—Å—è—á–Ω—ã–µ",
  }[targetId] || "—Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑—Ä—è–¥");

  const placeNameRound = (targetId) => ({
    tens: "–¥–µ—Å—è—Ç–∫–∏",
    hundreds: "—Å–æ—Ç–Ω–∏",
    thousands: "—Ç—ã—Å—è—á–∏",
    units: "—Ü–µ–ª—ã–µ",
    tenths: "–¥–µ—Å—è—Ç—ã–µ",
    hundredths: "—Å–æ—Ç—ã–µ",
    thousandths: "—Ç—ã—Å—è—á–Ω—ã–µ",
  }[targetId] || "—Ä–∞–∑—Ä—è–¥ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è");

  const getRange = (target, level) => {
    const lvl = Number(level) || 1;
    const step = target.step;
    if (step === 10)    return lvl === 1 ? [10,99] : (lvl === 2 ? [100,999] : [1000,9999]);
    if (step === 100)   return lvl === 1 ? [100,999] : (lvl === 2 ? [1000,9999] : [10000,99999]);
    if (step === 1000)  return lvl === 1 ? [1000,9999] : (lvl === 2 ? [10000,99999] : [100000,999999]);
    if (step <= 1)      return lvl === 1 ? [0,99] : (lvl === 2 ? [0,999] : [0,9999]);
    return [1,999];
  };

  const makeAppliedText = (displayN, targetLabel, target) => {
    const isIntLike = target.step >= 1;
    const intTemplates = [
      (x) => `–¶–µ–Ω–∞ —Ç–æ–≤–∞—Ä–∞ ${x} —Ä—É–±. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel} –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ—Ü–µ–Ω–∫–∏.`,
      (x) => `–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ ${x} –∫–º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–í –∑–∞–ª–µ ${x} –∑—Ä–∏—Ç–µ–ª–µ–π. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–ù–∞ —Å–∫–ª–∞–¥–µ ${x} –∫–æ—Ä–æ–±–æ–∫. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
    ];
    const decTemplates = [
      (x) => `–î–ª–∏–Ω–∞ –¥–æ—Å–∫–∏ ${x} –º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–ú–∞—Å—Å–∞ —Ç–æ–≤–∞—Ä–∞ ${x} –∫–≥. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–®–∏—Ä–∏–Ω–∞ –ª–µ–Ω—Ç—ã ${x} –º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
    ];
    const pool = isIntLike ? intTemplates : decTemplates;
    return pool[randInt(0, pool.length - 1)](displayN);
  };

  // ===== guide =====
  const getParts = (nScaled, decimalsInTask) => {
    const intPart = Math.floor(nScaled / BASE_SCALE);
    const frac = nScaled % BASE_SCALE;
    const fracStrFull = String(frac).padStart(BASE_DECIMALS, "0");
    const fracStr = decimalsInTask > 0 ? fracStrFull.slice(0, decimalsInTask) : "";
    return { intStr: String(intPart), fracStr };
  };

  const digitIndexFromPlace = (placeScaled, intLen) => {
    if (!Number.isFinite(placeScaled) || placeScaled <= 0) return null;
    if (placeScaled >= BASE_SCALE) {
      const k = Math.round(Math.log10(placeScaled / BASE_SCALE));
      return intLen - 1 - k;
    } else {
      const d = Math.round(Math.log10(BASE_SCALE / placeScaled));
      return intLen + 1 + (d - 1);
    }
  };

  const renderGuide = () => {
    if (!current) { el.guide.hidden = true; return; }

    const { intStr, fracStr } = getParts(current.nScaled, current.decimalsInTask);
    const full = fracStr ? `${intStr},${fracStr}` : intStr;

    const roundIdx = digitIndexFromPlace(current.roundPlaceScaled, intStr.length);
    const lookIdx  = digitIndexFromPlace(current.lookPlaceScaled,  intStr.length);

    if (roundIdx === null || lookIdx === null) { el.guide.hidden = true; return; }

    let html = "";
    for (let i = 0; i < full.length; i++) {
      const ch = full[i];
      let cls = "rf__d";
      if (ch === ",") cls += " rf__d--comma";
      else {
        if (i === roundIdx) cls += " rf__d--round";
        if (i === lookIdx)  cls += " rf__d--look";
        if (i > roundIdx)   cls += (current.turnToZero ? " rf__d--tozero" : " rf__d--drop");
      }
      html += `<span class="${cls}">${ch}</span>`;
    }

    el.guide.hidden = false;
    el.guideDigits.innerHTML = html;

    const rule = current.lookDigit >= 5 ? "–¶–∏—Ñ—Ä–∞ ‚â• 5 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä—è–¥." : "–¶–∏—Ñ—Ä–∞ < 5 ‚Üí —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º.";
    const tail = current.turnToZero ? "–°–ø—Ä–∞–≤–∞ —Å—Ç–∞–Ω—É—Ç –Ω—É–ª–∏ (–ø–æ–∫–∞–∑–∞–Ω–æ —Å–Ω–∏–∑—É)." : "–õ–∏—à–Ω–∏–µ –∑–Ω–∞–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º.";
    el.guideText.textContent = `–°–∏–Ω–∏–π ‚Äî —Ä–∞–∑—Ä—è–¥ (${current.roundName}). –û—Ä–∞–Ω–∂–µ–≤—ã–π ‚Äî —Å–º–æ—Ç—Ä–∏–º –Ω–∞ ${current.rightName}: —Ü–∏—Ñ—Ä–∞ ${current.lookDigit}. ${rule} ${tail}`;
  };

  const generateTask = () => {
    const target = getTarget(el.targetSelect.value);
    const level = el.levelSelect.value;

    const stepScaled = stepToScaled(target.step);
    const allowedDecimals = target.decimalsAnswer;

    let decimalsInTask = allowedDecimals;
    if (target.id === "units") decimalsInTask = Math.random() < 0.5 ? 1 : 2;
    else if (target.step < 1)  decimalsInTask = Math.min(BASE_DECIMALS, allowedDecimals + 1);
    else                       decimalsInTask = 0;

    const [minInt, maxInt] = getRange(target, level);

    let nScaled;
    if (decimalsInTask === 0) {
      let n = randInt(minInt, maxInt);
      if (target.step >= 10 && n % target.step === 0) {
        const add = randInt(1, Math.min(9, target.step - 1));
        if (n + add <= maxInt) n += add;
      }
      nScaled = n * BASE_SCALE;
    } else {
      const intPart = randInt(minInt, maxInt);
      const denom = Math.pow(10, decimalsInTask);
      const frac = randInt(0, denom - 1);
      const shift = Math.pow(10, BASE_DECIMALS - decimalsInTask);
      nScaled = intPart * BASE_SCALE + frac * shift;
    }

    const answerScaled = Math.round(nScaled / stepScaled) * stepScaled;
    const displayN = scaledToStringRu(nScaled, decimalsInTask);
    const displayAnswer = scaledToStringRu(answerScaled, allowedDecimals);

    const useApplied = el.appliedToggle.checked && Math.random() < APPLIED_PROB;
    const prompt = useApplied ? makeAppliedText(displayN, target.label, target) : `–û–∫—Ä—É–≥–ª–∏—Ç–µ —á–∏—Å–ª–æ ${displayN} ${target.label}.`;

    const lookPlace = rightPlaceScaled(stepScaled);
    const lookDigit = digitAt(nScaled, lookPlace);

    return {
      targetId: target.id,
      targetLabel: target.label,
      allowedDecimals,
      decimalsInTask,

      nScaled,
      displayN,
      answerScaled,
      displayAnswer,
      prompt,

      roundPlaceScaled: stepScaled,
      lookPlaceScaled: lookPlace,
      roundName: placeNameRound(target.id),
      rightName: placeNameRight(target.id),
      lookDigit,

      turnToZero: target.step >= 10,

      attempts: 0,
      solved: false,
    };
  };

  const setMessage = (text, kind) => {
    if (!text) { el.message.style.display = "none"; return; }
    el.message.style.display = "block";
    el.message.textContent = text;
    el.message.className = "rf__message " + (kind ? `rf__message--${kind}` : "");
  };

  const updateStatsUI = () => {
    el.statSolved.textContent = String(stats.solved);
    el.statCorrect.textContent = String(stats.correct);
    el.statAccuracy.textContent = stats.solved ? `${Math.round((stats.correct / stats.solved) * 100)}%` : "0%";
    el.statStreak.textContent = String(stats.streak);
  };

  const updateSeriesUI = () => {
    if (!series.active) {
      el.seriesText.textContent = "–°–µ—Ä–∏—è –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞";
      el.seriesBarFill.style.width = "0%";
      el.stopSeriesBtn.style.display = "none";
      return;
    }
    const done = series.index, total = series.size, left = Math.max(0, total - done);
    el.seriesText.textContent = `–ó–∞–¥–∞–Ω–∏–µ ${Math.min(done + 1, total)} –∏–∑ ${total} ‚Ä¢ –í–µ—Ä–Ω–æ: ${series.correct} ‚Ä¢ –û—Å—Ç–∞–ª–æ—Å—å: ${left}`;
    el.seriesBarFill.style.width = `${Math.round((done / total) * 100)}%`;
    el.stopSeriesBtn.style.display = "inline-flex";
  };

  const persist = () => {
    safeSave({
      targetId: el.targetSelect.value,
      level: el.levelSelect.value,
      applied: !!el.appliedToggle.checked,
      stats, series, current
    });
  };

  const restore = () => {
    const saved = safeLoad();
    if (!saved) return;

    if (typeof saved.targetId === "string") el.targetSelect.value = saved.targetId;
    if (typeof saved.level === "string") el.levelSelect.value = saved.level;
    if (typeof saved.applied === "boolean") el.appliedToggle.checked = saved.applied;

    if (saved.stats) stats = { ...stats, ...saved.stats };
    if (saved.series) series = { ...series, ...saved.series };

    // –≤–∞–ª–∏–¥–∏—Ä—É–µ–º current ‚Äî –∏–Ω–∞—á–µ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ "–±–µ–∑ –ø–æ–¥—Å–≤–µ—Ç–∫–∏"
    if (saved.current &&
        Number.isFinite(saved.current.nScaled) &&
        Number.isFinite(saved.current.decimalsInTask) &&
        Number.isFinite(saved.current.roundPlaceScaled) &&
        Number.isFinite(saved.current.lookPlaceScaled)) {
      current = saved.current;
      el.taskText.textContent = current.prompt;
      renderGuide();
    } else {
      current = null;
      el.guide.hidden = true;
    }

    updateStatsUI();
    updateSeriesUI();
  };

  const setCheckLocked = (locked) => {
    checkLocked = locked;
    el.checkBtn.disabled = locked;
    el.checkBtn.textContent = locked ? "–ü—Ä–æ–≤–µ—Ä—è—é‚Ä¶" : "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å";
  };

  const newTask = () => {
    current = generateTask();
    el.taskText.textContent = current.prompt;
    el.answerInput.value = "";
    el.answerInput.focus();
    el.solutionBox.style.display = "none";
    el.solutionBox.innerHTML = "";
    el.message.style.display = "none";
    renderGuide();
    persist();
  };

  const startSeries = () => {
    const size = Math.max(5, Math.min(30, Number(el.seriesSize.value) || 10));
    series = { active: true, size, index: 0, correct: 0 };
    updateSeriesUI();
    setMessage("–°–µ—Ä–∏—è –∑–∞–ø—É—â–µ–Ω–∞ ‚úÖ –†–µ—à–∞–π –∏ –∂–º–∏ ¬´–î–∞–ª—å—à–µ¬ª.", "ok");
    newTask();
  };

  const stopSeries = () => {
    series = { active: false, size: 10, index: 0, correct: 0 };
    updateSeriesUI();
    setMessage("–°–µ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞.", "info");
    persist();
  };

  const hintText = () => {
    if (!current) return "";
    return `–ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ–∫—Ä—É–≥–ª—è–µ–º ${current.targetLabel} ‚Üí —Å–º–æ—Ç—Ä–∏–º –Ω–∞ ${current.rightName}. 0‚Äì4 ‚Üí –Ω–µ –º–µ–Ω—è–µ–º; 5‚Äì9 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º.`;
  };

  const solutionHTML = () => {
    if (!current) return "";
    const d = current.lookDigit;
    const rule = d >= 5 ? `–¶–∏—Ñ—Ä–∞ ${d} ‚â• 5 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä—è–¥.` : `–¶–∏—Ñ—Ä–∞ ${d} < 5 ‚Üí —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º.`;
    return `<div class="rf__solutionTitle">–†–∞–∑–±–æ—Ä</div>
      <div>–û–∫—Ä—É–≥–ª—è–µ–º <b>${current.targetLabel}</b>.</div>
      <div>–°–º–æ—Ç—Ä–∏–º –Ω–∞ <b>${current.rightName}</b>: —Ü–∏—Ñ—Ä–∞ <b>${d}</b>.</div>
      <div>${rule}</div>
      <div class="rf__solutionAnswer">–û—Ç–≤–µ—Ç: <b>${current.displayAnswer}</b></div>`;
  };

  const checkAnswer = () => {
    if (checkLocked) return;
    if (!current) { setMessage("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª.", "info"); return; }

    setCheckLocked(true);
    setTimeout(() => setCheckLocked(false), CHECK_LOCK_MS);

    const norm = normalizeInput(el.answerInput.value);
    if (norm === "NEGATIVE_NOT_ALLOWED") { setMessage("–¢—Ä–µ–Ω–∏—Ä—É–µ–º –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª üôÇ", "bad"); return; }
    if (norm === "BAD_FORMAT" || !norm) { setMessage("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ —Ç–æ—á–∫–æ–π).", "info"); return; }

    const parsed = parseToScaled(norm, current.allowedDecimals);
    if (!parsed.ok) { setMessage("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç.", "bad"); return; }
    if (parsed.extraNonZero) { setMessage("–û—Ç–≤–µ—Ç –µ—â—ë –Ω–µ –æ–∫—Ä—É–≥–ª—ë–Ω –¥–æ –Ω—É–∂–Ω–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞ (–ª–∏—à–Ω–∏–µ —Ü–∏—Ñ—Ä—ã –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π).", "bad"); return; }

    current.attempts += 1;
    const ok = (parsed.scaled === current.answerScaled);

    stats.solved += 1;
    if (ok) {
      if (!current.solved) { current.solved = true; stats.correct += 1; }
      stats.streak += 1;
      setMessage("–í–µ—Ä–Ω–æ ‚úÖ", "ok");
    } else {
      stats.streak = 0;
      if (current.attempts >= 3) {
        setMessage(`–ù–µ–≤–µ—Ä–Ω–æ ‚ùå –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${current.displayAnswer}`, "bad");
        el.solutionBox.style.display = "block";
        el.solutionBox.innerHTML = solutionHTML();
      } else if (current.attempts >= 2) {
        setMessage("–ù–µ–≤–µ—Ä–Ω–æ ‚ùå " + hintText(), "bad");
      } else {
        setMessage("–ù–µ–≤–µ—Ä–Ω–æ ‚ùå –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.", "bad");
      }
    }

    updateStatsUI();
    persist();
  };

  const nextTask = () => {
    if (!current) { newTask(); return; }

    if (series.active) {
      series.index += 1;
      if (current.solved) series.correct += 1;
      updateSeriesUI();
      if (series.index >= series.size) {
        series.active = false;
        updateSeriesUI();
        setMessage(`–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç: ${series.correct}/${series.size}`, "ok");
        current = null;
        el.taskText.textContent = "–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª –∏–ª–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª.";
        el.answerInput.value = "";
        el.answerInput.blur();
        el.guide.hidden = true;
        persist();
        return;
      }
    }

    newTask();
  };

  const resetProgress = () => {
    const ok = confirm("–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —ç—Ç–æ–≥–æ —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞?");
    if (!ok) return;
    stats = { solved: 0, correct: 0, streak: 0, bestStreak: 0 };
    series = { active: false, size: 10, index: 0, correct: 0 };
    current = null;
    updateStatsUI(); updateSeriesUI();
    el.taskText.textContent = "–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω. –ù–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª.";
    el.answerInput.value = "";
    el.guide.hidden = true;
    el.message.style.display = "none";
    el.solutionBox.style.display = "none";
    el.solutionBox.innerHTML = "";
    if (storage) { try { storage.removeItem(STORAGE_KEY); } catch {} }
  };

  // events
  el.newBtn.addEventListener("click", newTask);
  el.startSeriesBtn.addEventListener("click", startSeries);
  el.stopSeriesBtn.addEventListener("click", stopSeries);
  el.checkBtn.addEventListener("click", checkAnswer);
  el.nextBtn.addEventListener("click", nextTask);
  el.answerInput.addEventListener("keydown", (e) => { if (e.key === "Enter") checkAnswer(); });
  el.hintBtn.addEventListener("click", () => { if (current) setMessage(hintText(), "info"); });
  el.solutionBtn.addEventListener("click", () => {
    if (!current) return;
    if (el.solutionBox.style.display === "none") { el.solutionBox.style.display = "block"; el.solutionBox.innerHTML = solutionHTML(); }
    else { el.solutionBox.style.display = "none"; el.solutionBox.innerHTML = ""; }
  });
  el.resetProgressBtn.addEventListener("click", resetProgress);
  el.targetSelect.addEventListener("change", () => { persist(); if (current) renderGuide(); });
  el.levelSelect.addEventListener("change", persist);
  el.appliedToggle.addEventListener("change", persist);

  // init
  fillTargetSelect();
  el.targetSelect.value = "tens";
  restore();
  updateStatsUI();
  updateSeriesUI();
})();
</script>
</body>
</html>

