<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–¢—Ä–µ–Ω–∞–∂—ë—Ä –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è ‚Äî v7</title>
  <link rel="stylesheet" href="rounding-fresh-v7.css?v=1" />
</head>
<body>
  <main class="rf7">
    <header class="rf7__header">
      <h1 class="rf7__title">–¢—Ä–µ–Ω–∞–∂—ë—Ä –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è <span class="rf7__badge">v7</span></h1>
      <p class="rf7__subtitle">–ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ä–∞–∑—Ä—è–¥–æ–≤ + –Ω—É–ª–∏ —Å–Ω–∏–∑—É + —É–º–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ + –ø–æ–≤—Ç–æ—Ä –æ—à–∏–±–æ–∫ + –¥–∏–Ω–∞–º–∏–∫–∞.</p>
      <p class="rf7__back"><a href="index.html">‚Üê –ù–∞ –≥–ª–∞–≤–Ω—É—é</a></p>
    </header>

    <section class="rf7__panel">
      <div class="rf7__row">
        <label class="rf7__label" for="targetSelect">–û–∫—Ä—É–≥–ª—è–µ–º:</label>
        <select id="targetSelect" class="rf7__select" aria-label="–í—ã–±–æ—Ä —Ä–∞–∑—Ä—è–¥–∞ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è"></select>

        <label class="rf7__label" for="levelSelect">–£—Ä–æ–≤–µ–Ω—å:</label>
        <select id="levelSelect" class="rf7__select rf7__select--small" aria-label="–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>

        <label class="rf7__toggle" title="–ò–Ω–æ–≥–¥–∞ –±—É–¥—É—Ç –∑–∞–¥–∞—á–∏ ‚Äú–∏–∑ –∂–∏–∑–Ω–∏‚Äù">
          <input type="checkbox" id="appliedToggle" checked />
          <span>–ü—Ä–∏–∫–ª–∞–¥–Ω—ã–µ</span>
        </label>

        <button id="newBtn" class="rf7__btn" type="button">–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä</button>
      </div>

      <div class="rf7__row rf7__row--series">
        <div class="rf7__seriesLeft">
          <span class="rf7__label">–°–µ—Ä–∏—è:</span>
          <select id="taskCount" class="rf7__select rf7__select--small" aria-label="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–¥–∞–Ω–∏–π –≤ —Å–µ—Ä–∏–∏">
            <option value="5">5</option>
            <option value="10" selected>10</option>
            <option value="15">15</option>
          </select>

          <button id="startSeriesBtn" class="rf7__btn rf7__btn--primary" type="button">–°—Ç–∞—Ä—Ç</button>
          <button id="stopSeriesBtn" class="rf7__btn rf7__btn--ghost" type="button" style="display:none;">–°–±—Ä–æ—Å</button>

          <button id="repeatErrorsBtn" class="rf7__btn rf7__btn--ghost" type="button" style="display:none;"
                  title="–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–∏—é —Ç–æ–ª—å–∫–æ –∏–∑ –∑–∞–¥–∞—á, –≥–¥–µ –±—ã–ª–∏ –æ—à–∏–±–∫–∏">
            –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ—à–∏–±–∫–∏
          </button>
        </div>

        <div class="rf7__seriesRight">
          <div id="seriesText" class="rf7__seriesText">–°–µ—Ä–∏—è –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞</div>
          <div class="rf7__bar" aria-hidden="true">
            <div id="seriesBarFill" class="rf7__barFill" style="width:0%"></div>
          </div>
          <div id="seriesMini" class="rf7__seriesMini">–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–µ—Ä–∏–∏: ‚Äî</div>
        </div>
      </div>

      <div class="rf7__stats">
        <div class="rf7__stat">
          <div class="rf7__statValue" id="statSolved">0</div>
          <div class="rf7__statLabel">–ü—Ä–æ–≤–µ—Ä–æ–∫</div>
        </div>
        <div class="rf7__stat">
          <div class="rf7__statValue" id="statCorrect">0</div>
          <div class="rf7__statLabel">–í–µ—Ä–Ω–æ</div>
        </div>
        <div class="rf7__stat">
          <div class="rf7__statValue" id="statAccuracy">0%</div>
          <div class="rf7__statLabel">–¢–æ—á–Ω–æ—Å—Ç—å</div>
        </div>
        <div class="rf7__stat">
          <div class="rf7__statValue" id="statStreak">0</div>
          <div class="rf7__statLabel">–°–µ—Ä–∏—è –≤–µ—Ä–Ω—ã—Ö</div>
        </div>
      </div>

      <div class="rf7__meta">
        –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –Ω–∞ –∑–∞–¥–∞–Ω–∏–µ: <b id="avgTime">‚Äî</b> ‚Ä¢ –ß–∞—â–µ –æ—à–∏–±–∫–∏: <b id="mostMistakes">‚Äî</b>
      </div>
    </section>

    <section class="rf7__card">
      <div class="rf7__taskLabel">–ó–∞–¥–∞–Ω–∏–µ</div>
      <div id="taskText" class="rf7__taskText">–ù–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª (–∏–ª–∏ ¬´–°—Ç–∞—Ä—Ç¬ª –¥–ª—è —Å–µ—Ä–∏–∏).</div>

      <div id="guide" class="rf7__guide" hidden>
        <div class="rf7__guideLabel">–ù–∞ —á—Ç–æ —Å–º–æ—Ç—Ä–∏–º</div>
        <div id="guideDigits" class="rf7__guideDigits"></div>
        <div id="guideText" class="rf7__guideText"></div>
      </div>

      <div class="rf7__answerRow">
        <label class="rf7__label" for="answerInput">–û—Ç–≤–µ—Ç:</label>
        <input id="answerInput" class="rf7__input" inputmode="decimal" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: 350 –∏–ª–∏ 3,14" aria-label="–ü–æ–ª–µ –≤–≤–æ–¥–∞ –æ—Ç–≤–µ—Ç–∞" />
        <button id="checkBtn" class="rf7__btn rf7__btn--check" type="button" aria-label="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ—Ç–≤–µ—Ç">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="nextBtn" class="rf7__btn rf7__btn--next" type="button" aria-label="–°–ª–µ–¥—É—é—â–∏–π –ø—Ä–∏–º–µ—Ä">–î–∞–ª—å—à–µ</button>
      </div>

      <div class="rf7__actions">
        <button id="hintBtn" class="rf7__btn rf7__btn--ghost" type="button">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
        <button id="solutionBtn" class="rf7__btn rf7__btn--ghost" type="button">–†–µ—à–µ–Ω–∏–µ</button>
        <button id="resetProgressBtn" class="rf7__btn rf7__btn--ghost" type="button">–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å</button>
      </div>

      <div id="message" class="rf7__message" aria-live="polite" style="display:none;"></div>
      <div id="solutionBox" class="rf7__solution" style="display:none;"></div>

      <div id="storageNote" class="rf7__storageNote" style="display:none;">
        –ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è (–±—Ä–∞—É–∑–µ—Ä –∑–∞–ø—Ä–µ—Ç–∏–ª —Ö—Ä–∞–Ω–∏–ª–∏—â–µ). –ù–∏—á–µ–≥–æ —Å—Ç—Ä–∞—à–Ω–æ–≥–æ ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.
      </div>
    </section>

    <details class="rf7__rules">
      <summary>–ü—Ä–∞–≤–∏–ª–æ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è</summary>
      <div class="rf7__rulesBody">
        <div class="rf7__step"><b>–®–∞–≥ 1.</b> –û–ø—Ä–µ–¥–µ–ª–∏ —Ä–∞–∑—Ä—è–¥, –¥–æ –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–∫—Ä—É–≥–ª—è–µ—à—å.</div>
        <div class="rf7__step"><b>–®–∞–≥ 2.</b> –ü–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ —Ü–∏—Ñ—Ä—É —Å–ø—Ä–∞–≤–∞ –æ—Ç —ç—Ç–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞.</div>
        <div class="rf7__step"><b>–®–∞–≥ 3.</b> 0‚Äì4 ‚Üí —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º; 5‚Äì9 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –Ω–∞ 1.</div>
        <div class="rf7__step"><b>–®–∞–≥ 4.</b> –î–ª—è —Ü–µ–ª—ã—Ö —Å–ø—Ä–∞–≤–∞ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω—É–ª–∏, –¥–ª—è –¥—Ä–æ–±–µ–π –ª–∏—à–Ω–∏–µ –∑–Ω–∞–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º.</div>
      </div>
    </details>
  </main>

  <div id="toast" class="rf7__toast" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  // ===== config =====
  const BASE_SCALE = 10000;
  const BASE_DECIMALS = 4;
  const STORAGE_KEY = "rounding_fresh_v7_state";
  const CHECK_LOCK_MS = 1100;
  const APPLIED_PROB = 0.22;
  const DUP_GUARD_TRIES = 12;

  const $ = (id) => document.getElementById(id);

  const el = {
    targetSelect: $("targetSelect"),
    levelSelect: $("levelSelect"),
    appliedToggle: $("appliedToggle"),
    newBtn: $("newBtn"),

    taskCount: $("taskCount"),
    startSeriesBtn: $("startSeriesBtn"),
    stopSeriesBtn: $("stopSeriesBtn"),
    repeatErrorsBtn: $("repeatErrorsBtn"),

    seriesText: $("seriesText"),
    seriesBarFill: $("seriesBarFill"),
    seriesMini: $("seriesMini"),

    statSolved: $("statSolved"),
    statCorrect: $("statCorrect"),
    statAccuracy: $("statAccuracy"),
    statStreak: $("statStreak"),

    avgTime: $("avgTime"),
    mostMistakes: $("mostMistakes"),

    taskText: $("taskText"),
    guide: $("guide"),
    guideDigits: $("guideDigits"),
    guideText: $("guideText"),

    answerInput: $("answerInput"),
    checkBtn: $("checkBtn"),
    nextBtn: $("nextBtn"),

    hintBtn: $("hintBtn"),
    solutionBtn: $("solutionBtn"),
    resetProgressBtn: $("resetProgressBtn"),

    message: $("message"),
    solutionBox: $("solutionBox"),
    storageNote: $("storageNote"),
    toast: $("toast"),
  };

  // ===== storage safe =====
  const storage = (() => {
    try {
      const t = "__t";
      localStorage.setItem(t, "1");
      localStorage.removeItem(t);
      return localStorage;
    } catch { return null; }
  })();

  if (!storage) el.storageNote.style.display = "block";

  const safeLoad = () => {
    if (!storage) return null;
    try {
      const raw = storage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  };

  const safeSave = (obj) => {
    if (!storage) return;
    try { storage.setItem(STORAGE_KEY, JSON.stringify(obj)); } catch {}
  };

  // ===== helpers =====
  const nowMs = () => (typeof performance !== "undefined" ? performance.now() : Date.now());
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  const toast = (text) => {
    if (!text) return;
    el.toast.textContent = text;
    el.toast.classList.add("is-show");
    window.setTimeout(() => el.toast.classList.remove("is-show"), 1600);
  };

  const formatTime = (ms) => {
    if (!Number.isFinite(ms) || ms <= 0) return "‚Äî";
    const s = Math.round(ms / 1000);
    const m = Math.floor(s / 60);
    const r = s % 60;
    return m > 0 ? `${m}:${String(r).padStart(2, "0")}` : `${r}—Å`;
  };

  const scaledToStringRu = (scaled, decimals) => {
    const abs = Math.abs(scaled);
    const intPart = Math.floor(abs / BASE_SCALE);
    const frac = abs % BASE_SCALE;
    if (decimals <= 0) return String(intPart);
    const fracStrFull = String(frac).padStart(BASE_DECIMALS, "0");
    return `${intPart},${fracStrFull.slice(0, decimals)}`;
  };

  const normalizeInputDetailed = (raw, allowedDecimals) => {
    const original = String(raw || "").trim();
    let t = original.replace(/\s+/g, "").replace(",", ".");
    if (!t) return { kind: "empty" };

    if (t[0] === "+") t = t.slice(1);
    if (t[0] === "-") return { kind: "negative" };
    if (!/^\d+(\.\d+)?$/.test(t)) return { kind: "bad" };

    const parts = t.split(".");
    let intPart = (parts[0] || "0").replace(/^0+(?=\d)/, "");
    if (intPart === "") intPart = "0";

    const frac = parts[1] ?? null;
    const norm = frac === null ? intPart : (intPart + "." + frac);

    let hasExtraZeros = false;
    if (frac !== null && frac.length > allowedDecimals) {
      const extra = frac.slice(allowedDecimals);
      hasExtraZeros = extra.length > 0 && [...extra].every(ch => ch === "0");
    }
    return { kind: "ok", norm, hasExtraZeros };
  };

  const parseToScaled = (inputNorm, allowedDecimals) => {
    const parts = inputNorm.split(".");
    const intVal = parseInt(parts[0], 10);
    if (!Number.isFinite(intVal)) return { ok: false };
    const fracRaw = parts[1] || "";

    let extraNonZero = false;
    if (fracRaw.length > allowedDecimals) {
      extraNonZero = [...fracRaw.slice(allowedDecimals)].some(ch => ch !== "0");
    }

    const fracPadded = (fracRaw + "0".repeat(BASE_DECIMALS)).slice(0, BASE_DECIMALS);
    const fracVal = parseInt(fracPadded || "0", 10);

    const scaled = intVal * BASE_SCALE + (Number.isFinite(fracVal) ? fracVal : 0);
    return { ok: true, scaled, extraNonZero };
  };

  const stepToScaled = (step) => Math.round(step * BASE_SCALE);
  const rightPlaceScaled = (stepScaled) => Math.floor(stepScaled / 10);
  const digitAt = (nScaled, placeScaled) => Math.floor(nScaled / placeScaled) % 10;

  // ===== targets =====
  const TARGETS = [
    { id: "tens",        label: "–¥–æ –¥–µ—Å—è—Ç–∫–æ–≤",        step: 10,    decimalsAnswer: 0 },
    { id: "hundreds",    label: "–¥–æ —Å–æ—Ç–µ–Ω",          step: 100,   decimalsAnswer: 0 },
    { id: "thousands",   label: "–¥–æ —Ç—ã—Å—è—á",          step: 1000,  decimalsAnswer: 0 },
    { id: "units",       label: "–¥–æ —Ü–µ–ª—ã—Ö",          step: 1,     decimalsAnswer: 0 },
    { id: "tenths",      label: "–¥–æ –¥–µ—Å—è—Ç—ã—Ö",        step: 0.1,   decimalsAnswer: 1 },
    { id: "hundredths",  label: "–¥–æ —Å–æ—Ç—ã—Ö",          step: 0.01,  decimalsAnswer: 2 },
    { id: "thousandths", label: "–¥–æ —Ç—ã—Å—è—á–Ω—ã—Ö",       step: 0.001, decimalsAnswer: 3 },
  ];

  const fillTargetSelect = () => {
    el.targetSelect.innerHTML = "";
    for (const t of TARGETS) {
      const opt = document.createElement("option");
      opt.value = t.id;
      opt.textContent = t.label;
      el.targetSelect.appendChild(opt);
    }
  };

  const getTarget = (id) => TARGETS.find(t => t.id === id) || TARGETS[0];

  const roundName = (id) => ({
    tens: "–¥–µ—Å—è—Ç–∫–∏", hundreds: "—Å–æ—Ç–Ω–∏", thousands: "—Ç—ã—Å—è—á–∏",
    units: "—Ü–µ–ª—ã–µ", tenths: "–¥–µ—Å—è—Ç—ã–µ", hundredths: "—Å–æ—Ç—ã–µ", thousandths: "—Ç—ã—Å—è—á–Ω—ã–µ"
  }[id] || "—Ä–∞–∑—Ä—è–¥");

  const rightName = (id) => ({
    tens: "–µ–¥–∏–Ω–∏—Ü—ã", hundreds: "–¥–µ—Å—è—Ç–∫–∏", thousands: "—Å–æ—Ç–Ω–∏",
    units: "–¥–µ—Å—è—Ç—ã–µ", tenths: "—Å–æ—Ç—ã–µ", hundredths: "—Ç—ã—Å—è—á–Ω—ã–µ", thousandths: "–¥–µ—Å—è—Ç–∏—Ç—ã—Å—è—á–Ω—ã–µ"
  }[id] || "—Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑—Ä—è–¥");

  const getRange = (target, level) => {
    const lvl = Number(level) || 1;
    const step = target.step;
    if (step === 10)   return lvl === 1 ? [10,99] : (lvl === 2 ? [100,999] : [1000,9999]);
    if (step === 100)  return lvl === 1 ? [100,999] : (lvl === 2 ? [1000,9999] : [10000,99999]);
    if (step === 1000) return lvl === 1 ? [1000,9999] : (lvl === 2 ? [10000,99999] : [100000,999999]);
    if (step <= 1)     return lvl === 1 ? [0,99] : (lvl === 2 ? [0,999] : [0,9999]);
    return [1,999];
  };

  const appliedText = (displayN, targetLabel, isInt) => {
    const ints = [
      (x) => `–¶–µ–Ω–∞ —Ç–æ–≤–∞—Ä–∞ ${x} —Ä—É–±. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel} –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ—Ü–µ–Ω–∫–∏.`,
      (x) => `–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ ${x} –∫–º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–°–∫–æ—Ä–æ—Å—Ç—å ${x} –∫–º/—á. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–í –∑–∞–ª–µ ${x} –∑—Ä–∏—Ç–µ–ª–µ–π. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ ${x}¬∞C. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
    ];
    const decs = [
      (x) => `–î–ª–∏–Ω–∞ –¥–æ—Å–∫–∏ ${x} –º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–ú–∞—Å—Å–∞ —Ç–æ–≤–∞—Ä–∞ ${x} –∫–≥. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
      (x) => `–®–∏—Ä–∏–Ω–∞ –ª–µ–Ω—Ç—ã ${x} –º. –û–∫—Ä—É–≥–ª–∏—Ç–µ ${targetLabel}.`,
    ];
    const pool = isInt ? ints : decs;
    return pool[randInt(0, pool.length - 1)](displayN);
  };

  // ===== state =====
  let stats = { solved: 0, correct: 0, streak: 0 };
  let series = { active: false, size: 10, index: 0, correct: 0, mode: "normal" }; // mode: normal|repeat
  let current = null;
  let locked = false;

  let timeSumMs = 0;
  let timeCount = 0;
  let taskStartMs = null;

  let mistakesByTarget = {};
  let mistakesThisSeries = {};
  let sessions = []; // last 3 series summaries

  // tasks with mistakes to repeat
  let repeatPool = [];   // array of task snapshots
  let repeatQueue = [];  // queue for repeat-mode
  let recentKeys = [];   // for anti-repeat

  const persist = (withToast=false) => {
    safeSave({
      targetId: el.targetSelect.value,
      level: el.levelSelect.value,
      applied: !!el.appliedToggle.checked,
      taskCount: el.taskCount.value,

      stats, series, current,
      timeSumMs, timeCount, taskStartMs,
      mistakesByTarget, mistakesThisSeries,
      sessions,
      repeatPool
    });
    if (withToast) toast("–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω");
  };

  const restore = () => {
    const s = safeLoad();
    if (!s) return;

    if (typeof s.targetId === "string") el.targetSelect.value = s.targetId;
    if (typeof s.level === "string") el.levelSelect.value = s.level;
    if (typeof s.applied === "boolean") el.appliedToggle.checked = s.applied;
    if (typeof s.taskCount === "string") el.taskCount.value = s.taskCount;

    if (s.stats) stats = { ...stats, ...s.stats };
    if (s.series) series = { ...series, ...s.series };

    if (Number.isFinite(s.timeSumMs)) timeSumMs = s.timeSumMs;
    if (Number.isFinite(s.timeCount)) timeCount = s.timeCount;
    if (Number.isFinite(s.taskStartMs)) taskStartMs = s.taskStartMs;

    if (s.mistakesByTarget && typeof s.mistakesByTarget === "object") mistakesByTarget = s.mistakesByTarget;
    if (s.mistakesThisSeries && typeof s.mistakesThisSeries === "object") mistakesThisSeries = s.mistakesThisSeries;

    if (Array.isArray(s.sessions)) sessions = s.sessions.slice(0, 3);
    if (Array.isArray(s.repeatPool)) repeatPool = s.repeatPool;

    if (s.current && Number.isFinite(s.current.nScaled)) {
      current = s.current;
      el.taskText.textContent = current.prompt;
      renderGuide();
    }
  };

  // ===== UI =====
  const setMessage = (text, kind) => {
    if (!text) { el.message.style.display = "none"; return; }
    el.message.style.display = "block";
    el.message.textContent = text;
    el.message.className = "rf7__message " + (kind ? `rf7__message--${kind}` : "");
  };

  const updateStatsUI = () => {
    el.statSolved.textContent = String(stats.solved);
    el.statCorrect.textContent = String(stats.correct);
    el.statAccuracy.textContent = stats.solved ? `${Math.round((stats.correct / stats.solved) * 100)}%` : "0%";
    el.statStreak.textContent = String(stats.streak);
  };

  const updateSeriesUI = () => {
    if (!series.active) {
      el.seriesText.textContent = "–°–µ—Ä–∏—è –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞";
      el.seriesBarFill.style.width = "0%";
      el.stopSeriesBtn.style.display = "none";
      return;
    }
    el.stopSeriesBtn.style.display = "inline-flex";
    const done = series.index, total = series.size, left = Math.max(0, total - done);
    const modeTxt = series.mode === "repeat" ? " (–ø–æ–≤—Ç–æ—Ä –æ—à–∏–±–æ–∫)" : "";
    el.seriesText.textContent = `–ó–∞–¥–∞–Ω–∏–µ ${Math.min(done + 1, total)} –∏–∑ ${total}${modeTxt} ‚Ä¢ –í–µ—Ä–Ω–æ: ${series.correct} ‚Ä¢ –û—Å—Ç–∞–ª–æ—Å—å: ${left}`;
    el.seriesBarFill.style.width = `${Math.round((done / total) * 100)}%`;
  };

  const updateMeta = () => {
    const avg = timeCount > 0 ? (timeSumMs / timeCount) : null;
    el.avgTime.textContent = avg ? formatTime(avg) : "‚Äî";

    // most mistakes
    const entries = Object.entries(mistakesByTarget);
    if (entries.length === 0) el.mostMistakes.textContent = "‚Äî";
    else {
      entries.sort((a,b) => b[1] - a[1]);
      const topId = entries[0][0];
      el.mostMistakes.textContent = (getTarget(topId)?.label) || "‚Äî";
    }

    // last 3 series
    if (!Array.isArray(sessions) || sessions.length === 0) {
      el.seriesMini.textContent = "–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–µ—Ä–∏–∏: ‚Äî";
      return;
    }
    const sTxt = sessions.map(x => `${x.correct}/${x.total}`).join(" ‚Üí ");
    let trend = "";
    if (sessions.length >= 2) {
      const a = sessions[0].correct / sessions[0].total;
      const b = sessions[1].correct / sessions[1].total;
      const diff = Math.round((a - b) * 100);
      if (diff !== 0) trend = diff > 0 ? ` (–ª—É—á—à–µ –Ω–∞ +${diff}%)` : ` (—Ö—É–∂–µ –Ω–∞ ${diff}%)`;
    }
    el.seriesMini.textContent = `–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–µ—Ä–∏–∏: ${sTxt}${trend}`;
  };

  const setLocked = (v) => {
    locked = v;
    el.checkBtn.disabled = v;
    el.checkBtn.textContent = v ? "–ü—Ä–æ–≤–µ—Ä—è—é‚Ä¶" : "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å";
  };

  const addMistake = (targetId, isSeries) => {
    mistakesByTarget[targetId] = (mistakesByTarget[targetId] || 0) + 1;
    if (isSeries) mistakesThisSeries[targetId] = (mistakesThisSeries[targetId] || 0) + 1;
  };

  // ===== guide =====
  const digitIndexFromPlace = (placeScaled, intLen) => {
    if (placeScaled >= BASE_SCALE) {
      const k = Math.round(Math.log10(placeScaled / BASE_SCALE));
      return intLen - 1 - k;
    } else {
      const d = Math.round(Math.log10(BASE_SCALE / placeScaled));
      return intLen + 1 + (d - 1);
    }
  };

  const renderGuide = () => {
    if (!current) { el.guide.hidden = true; return; }

    const intPart = Math.floor(current.nScaled / BASE_SCALE);
    const frac = current.nScaled % BASE_SCALE;

    const intStr = String(intPart);
    const fracStrFull = String(frac).padStart(BASE_DECIMALS, "0");
    const fracStr = current.decimalsInTask > 0 ? fracStrFull.slice(0, current.decimalsInTask) : "";
    const full = fracStr ? `${intStr},${fracStr}` : intStr;

    const roundIdx = digitIndexFromPlace(current.roundPlaceScaled, intStr.length);
    const lookIdx  = digitIndexFromPlace(current.lookPlaceScaled,  intStr.length);

    let html = "";
    for (let i = 0; i < full.length; i++) {
      const ch = full[i];
      let cls = "rf7__d";
      if (ch === ",") cls += " rf7__d--comma";
      else {
        if (i === roundIdx) cls += " rf7__d--round";
        if (i === lookIdx)  cls += " rf7__d--look";
        if (i > roundIdx)   cls += (current.turnToZero ? " rf7__d--tozero" : " rf7__d--drop");
      }
      html += `<span class="${cls}">${ch}</span>`;
    }

    el.guide.hidden = false;
    el.guideDigits.innerHTML = html;

    const rule = current.lookDigit >= 5 ? "–¶–∏—Ñ—Ä–∞ ‚â• 5 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä—è–¥." : "–¶–∏—Ñ—Ä–∞ < 5 ‚Üí —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º.";
    const tail = current.turnToZero ? "–°–ø—Ä–∞–≤–∞ –±—É–¥—É—Ç –Ω—É–ª–∏ (0 –ø–æ–∫–∞–∑–∞–Ω—ã —Å–Ω–∏–∑—É)." : "–õ–∏—à–Ω–∏–µ –∑–Ω–∞–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º.";
    el.guideText.textContent = `–°–∏–Ω–∏–π ‚Äî —Ä–∞–∑—Ä—è–¥ (${current.roundName}). –û—Ä–∞–Ω–∂–µ–≤—ã–π ‚Äî —Å–º–æ—Ç—Ä–∏–º –Ω–∞ ${current.rightName}: —Ü–∏—Ñ—Ä–∞ ${current.lookDigit}. ${rule} ${tail}`;
  };

  // ===== task generation =====
  const makeTask = () => {
    const target = getTarget(el.targetSelect.value);
    const level = el.levelSelect.value;

    const stepScaled = stepToScaled(target.step);
    const allowedDecimals = target.decimalsAnswer;

    let decimalsInTask;
    if (target.id === "units") decimalsInTask = Math.random() < 0.5 ? 1 : 2;
    else if (target.step < 1)  decimalsInTask = Math.min(BASE_DECIMALS, allowedDecimals + 1);
    else                       decimalsInTask = 0;

    const [minInt, maxInt] = getRange(target, level);

    let nScaled;
    if (decimalsInTask === 0) {
      let n = randInt(minInt, maxInt);
      if (target.step >= 10 && n % target.step === 0) n += 1;
      nScaled = n * BASE_SCALE;
    } else {
      const intPart = randInt(minInt, maxInt);
      const denom = Math.pow(10, decimalsInTask);
      const frac = randInt(0, denom - 1);
      const shift = Math.pow(10, BASE_DECIMALS - decimalsInTask);
      nScaled = intPart * BASE_SCALE + frac * shift;
    }

    const answerScaled = Math.round(nScaled / stepScaled) * stepScaled;
    const displayN = scaledToStringRu(nScaled, decimalsInTask);
    const displayAnswer = scaledToStringRu(answerScaled, allowedDecimals);

    const useApplied = el.appliedToggle.checked && Math.random() < APPLIED_PROB;
    const prompt = useApplied
      ? appliedText(displayN, target.label, target.step >= 1)
      : `–û–∫—Ä—É–≥–ª–∏—Ç–µ —á–∏—Å–ª–æ ${displayN} ${target.label}.`;

    const lookPlace = rightPlaceScaled(stepScaled);
    const lookDigit = digitAt(nScaled, lookPlace);

    return {
      targetId: target.id,
      targetLabel: target.label,
      allowedDecimals,
      decimalsInTask,

      nScaled,
      answerScaled,
      displayAnswer,
      prompt,

      roundPlaceScaled: stepScaled,
      lookPlaceScaled: lookPlace,
      roundName: roundName(target.id),
      rightName: rightName(target.id),
      lookDigit,

      turnToZero: target.step >= 10,
      attempts: 0,
      solved: false,
      hadMistake: false
    };
  };

  const nextGeneratedTask = () => {
    // –∞–Ω—Ç–∏-–ø–æ–≤—Ç–æ—Ä—ã –≤ –æ–¥–Ω–æ–π —Å–µ—Å—Å–∏–∏
    for (let i = 0; i < DUP_GUARD_TRIES; i++) {
      const t = makeTask();
      const key = `${t.targetId}:${t.nScaled}:${t.decimalsInTask}`;
      if (!recentKeys.includes(key)) {
        recentKeys.push(key);
        if (recentKeys.length > 50) recentKeys.shift();
        return t;
      }
    }
    return makeTask();
  };

  const snapshotForRepeat = (t) => ({
    targetId: t.targetId,
    targetLabel: t.targetLabel,
    allowedDecimals: t.allowedDecimals,
    decimalsInTask: t.decimalsInTask,
    nScaled: t.nScaled,
    answerScaled: t.answerScaled,
    displayAnswer: t.displayAnswer,
    // –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞ —É–±–µ—Ä—ë–º "–ø—Ä–∏–∫–ª–∞–¥–Ω—É—é –æ–±–≤—è–∑–∫—É", —á—Ç–æ–±—ã –±—ã–ª–æ –∫–æ—Ä–æ—Ç–∫–æ
    prompt: `–û–∫—Ä—É–≥–ª–∏—Ç–µ —á–∏—Å–ª–æ ${scaledToStringRu(t.nScaled, t.decimalsInTask)} ${t.targetLabel}.`,
    roundPlaceScaled: t.roundPlaceScaled,
    lookPlaceScaled: t.lookPlaceScaled,
    roundName: t.roundName,
    rightName: t.rightName,
    lookDigit: t.lookDigit,
    turnToZero: t.turnToZero
  });

  // ===== timer =====
  const startTaskTimer = () => { taskStartMs = nowMs(); };
  const finishTaskTimer = () => {
    if (!Number.isFinite(taskStartMs)) return;
    const dt = nowMs() - taskStartMs;
    timeSumMs += dt;
    timeCount += 1;
    taskStartMs = null;
  };

  const setRepeatButtonVisibility = () => {
    el.repeatErrorsBtn.style.display = (!series.active && repeatPool.length > 0) ? "inline-flex" : "none";
  };

  const newTask = () => {
    if (series.active && series.mode === "repeat") {
      // repeat queue
      const next = repeatQueue.shift();
      if (!next) {
        // –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –ø–æ–≤—Ç–æ—Ä—ã
        series.active = false;
        updateSeriesUI();
        setMessage("–ü–æ–≤—Ç–æ—Ä –æ—à–∏–±–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω ‚úÖ", "ok");
        setRepeatButtonVisibility();
        persist(true);
        current = null;
        el.taskText.textContent = "–ù–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª –∏–ª–∏ –Ω–∞—á–Ω–∏ –Ω–æ–≤—É—é —Å–µ—Ä–∏—é.";
        el.answerInput.value = "";
        el.answerInput.blur();
        el.guide.hidden = true;
        return;
      }
      current = { ...next, attempts: 0, solved: false, hadMistake: false };
    } else {
      current = nextGeneratedTask();
    }

    el.taskText.textContent = current.prompt;
    el.answerInput.value = "";
    el.answerInput.focus();

    el.solutionBox.style.display = "none";
    el.solutionBox.innerHTML = "";
    el.message.style.display = "none";

    renderGuide();
    startTaskTimer();
    persist(false);
  };

  const startSeries = () => {
    const size = Number(el.taskCount.value) || 10;
    series = { active: true, size, index: 0, correct: 0, mode: "normal" };
    mistakesThisSeries = {};
    repeatPool = [];
    updateSeriesUI();
    setRepeatButtonVisibility();
    setMessage("–°–µ—Ä–∏—è –∑–∞–ø—É—â–µ–Ω–∞ ‚úÖ –†–µ—à–∞–π –∏ –∂–º–∏ ¬´–î–∞–ª—å—à–µ¬ª.", "ok");
    newTask();
    persist(true);
  };

  const stopSeries = () => {
    series = { active: false, size: 10, index: 0, correct: 0, mode: "normal" };
    mistakesThisSeries = {};
    updateSeriesUI();
    setMessage("–°–µ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞.", "info");
    setRepeatButtonVisibility();
    persist(true);
  };

  const startRepeatErrors = () => {
    if (repeatPool.length === 0) return;
    // –æ—á–µ—Ä–µ–¥—å = —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ –∫–ª—é—á—É
    const seen = new Set();
    repeatQueue = [];
    for (const t of repeatPool) {
      const key = `${t.targetId}:${t.nScaled}:${t.decimalsInTask}`;
      if (!seen.has(key)) {
        seen.add(key);
        repeatQueue.push(t);
      }
    }

    series = { active: true, size: repeatQueue.length, index: 0, correct: 0, mode: "repeat" };
    mistakesThisSeries = {};
    updateSeriesUI();
    setRepeatButtonVisibility();
    setMessage("–ü–æ–≤—Ç–æ—Ä –æ—à–∏–±–æ–∫ –∑–∞–ø—É—â–µ–Ω ‚úÖ", "ok");
    newTask();
    persist(true);
  };

  const hintText = () => {
    if (!current) return "";
    return `–ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ–∫—Ä—É–≥–ª—è–µ–º ${current.targetLabel} ‚Üí —Å–º–æ—Ç—Ä–∏–º –Ω–∞ ${current.rightName}. 0‚Äì4 ‚Üí –Ω–µ –º–µ–Ω—è–µ–º; 5‚Äì9 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º.`;
  };

  const solutionHTML = () => {
    if (!current) return "";
    const d = current.lookDigit;
    const rule = d >= 5 ? `–¶–∏—Ñ—Ä–∞ ${d} ‚â• 5 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä—è–¥.` : `–¶–∏—Ñ—Ä–∞ ${d} < 5 ‚Üí —Ä–∞–∑—Ä—è–¥ –Ω–µ –º–µ–Ω—è–µ–º.`;
    return `<div class="rf7__solutionTitle">–†–∞–∑–±–æ—Ä</div>
      <div>–û–∫—Ä—É–≥–ª—è–µ–º <b>${current.targetLabel}</b>.</div>
      <div>–°–º–æ—Ç—Ä–∏–º –Ω–∞ <b>${current.rightName}</b>: —Ü–∏—Ñ—Ä–∞ <b>${d}</b>.</div>
      <div>${rule}</div>
      <div class="rf7__solutionAnswer">–û—Ç–≤–µ—Ç: <b>${current.displayAnswer}</b></div>`;
  };

  const diagnoseMistake = (userScaled) => {
    // A) –Ω–µ –∫—Ä–∞—Ç–Ω–æ —à–∞–≥—É, –µ—Å–ª–∏ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–µ—Å—è—Ç–∫–æ–≤/—Å–æ—Ç–µ–Ω/—Ç—ã—Å—è—á
    if (current.turnToZero && (userScaled % current.roundPlaceScaled !== 0)) {
      return `–ü—Ä–æ–≤–µ—Ä—å –Ω—É–ª–∏ —Å–ø—Ä–∞–≤–∞: –ø—Ä–∏ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–∏ ${current.targetLabel} –æ—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ä–∞—Ç–µ–Ω —à–∞–≥—É.`;
    }

    // B) –ø—Ä–æ–º–∞—Ö —Ä–æ–≤–Ω–æ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
    const diff = userScaled - current.answerScaled;
    if (Math.abs(diff) === current.roundPlaceScaled) {
      return `–ü—Ä–æ–º–∞—Ö –Ω–∞ 1 —à–∞–≥. –ü—Ä–æ–≤–µ—Ä—å —Ü–∏—Ñ—Ä—É —Å–ø—Ä–∞–≤–∞: 5‚Äì9 ‚Üí —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º, 0‚Äì4 ‚Üí –Ω–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º.`;
    }

    // C) –≤–æ–∑–º–æ–∂–Ω–æ –æ–∫—Ä—É–≥–ª–∏–ª –¥–æ –¥—Ä—É–≥–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞ (—Å–ª–∏—à–∫–æ–º ‚Äú–∫—Ä—É–ø–Ω–æ‚Äù)
    if (current.turnToZero) {
      const bigger = current.roundPlaceScaled * 10;
      const ansBigger = Math.round(current.nScaled / bigger) * bigger;
      if (userScaled === ansBigger) {
        const cur = getTarget(current.targetId)?.label || "—ç—Ç–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞";
        // –ø–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–∑–≤–∞—Ç—å ‚Äú–Ω–∞ –æ–¥–∏–Ω —Ä–∞–∑—Ä—è–¥ –∫—Ä—É–ø–Ω–µ–µ‚Äù
        let msg = "–ü–æ—Ö–æ–∂–µ, —Ç—ã –æ–∫—Ä—É–≥–ª–∏–ª –¥–æ –±–æ–ª–µ–µ –∫—Ä—É–ø–Ω–æ–≥–æ —Ä–∞–∑—Ä—è–¥–∞. ";
        msg += `–ù—É–∂–Ω–æ ${cur}.`;
        return msg;
      }
    }

    // D) –æ–±—â–∏–π —Å–æ–≤–µ—Ç
    return `–ü—Ä–æ–≤–µ—Ä—å: –º—ã –æ–∫—Ä—É–≥–ª—è–µ–º ${current.targetLabel} –∏ —Å–º–æ—Ç—Ä–∏–º –Ω–∞ ${current.rightName}.`;
  };

  const checkAnswer = () => {
    if (locked) return;
    if (!current) { setMessage("–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª.", "info"); return; }

    setLocked(true);
    setTimeout(() => setLocked(false), CHECK_LOCK_MS);

    const det = normalizeInputDetailed(el.answerInput.value, current.allowedDecimals);
    if (det.kind === "negative") { setMessage("–¢—Ä–µ–Ω–∏—Ä—É–µ–º –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª üôÇ", "bad"); return; }
    if (det.kind === "bad" || det.kind === "empty") { setMessage("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–º–æ–∂–Ω–æ —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ —Ç–æ—á–∫–æ–π).", "info"); return; }

    const parsed = parseToScaled(det.norm, current.allowedDecimals);
    if (!parsed.ok) { setMessage("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç.", "bad"); return; }

    if (parsed.extraNonZero) {
      current.hadMistake = true;
      setMessage("–õ–∏—à–Ω–∏–µ —Ü–∏—Ñ—Ä—ã –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π: –æ–∫—Ä—É–≥–ª–∏ –¥–æ –Ω—É–∂–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤.", "bad");
      return;
    }

    current.attempts += 1;
    const ok = (parsed.scaled === current.answerScaled);

    stats.solved += 1;

    if (ok) {
      if (!current.solved) { current.solved = true; stats.correct += 1; }
      stats.streak += 1;

      if (det.hasExtraZeros && current.allowedDecimals > 0) {
        setMessage(`–í–µ—Ä–Ω–æ ‚úÖ (–º–æ–∂–Ω–æ –∫–æ—Ä–æ—á–µ: ${current.displayAnswer})`, "ok");
      } else {
        setMessage("–í–µ—Ä–Ω–æ ‚úÖ", "ok");
      }
    } else {
      stats.streak = 0;
      current.hadMistake = true;

      const diag = diagnoseMistake(parsed.scaled);

      if (current.attempts >= 3) {
        setMessage(`–ù–µ–≤–µ—Ä–Ω–æ ‚ùå ${diag} –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${current.displayAnswer}`, "bad");
        el.solutionBox.style.display = "block";
        el.solutionBox.innerHTML = solutionHTML();
      } else if (current.attempts >= 2) {
        setMessage(`–ù–µ–≤–µ—Ä–Ω–æ ‚ùå ${diag}`, "bad");
      } else {
        setMessage("–ù–µ–≤–µ—Ä–Ω–æ ‚ùå –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.", "bad");
      }
    }

    updateStatsUI();
    updateMeta();
    persist(false);
  };

  const finishSeriesIfNeeded = () => {
    if (!series.active) return;
    if (series.index >= series.size) {
      series.active = false;
      updateSeriesUI();

      // —Å–æ—Ö—Ä–∞–Ω–∏–º ‚Äú–¥–∏–Ω–∞–º–∏–∫—É‚Äù (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 —Å–µ—Ä–∏–∏)
      const summary = {
        ts: Date.now(),
        correct: series.correct,
        total: series.size,
        avgMs: (timeCount > 0 ? (timeSumMs / timeCount) : null)
      };
      sessions = [summary, ...sessions].slice(0, 3);

      // –ø–æ–∫–∞–∂–µ–º –≥–¥–µ —á–∞—â–µ –æ—à–∏–±–∫–∞ –≤ —ç—Ç–æ–π —Å–µ—Ä–∏–∏
      let most = "‚Äî";
      const entries = Object.entries(mistakesThisSeries);
      if (entries.length > 0) {
        entries.sort((a,b) => b[1] - a[1]);
        most = getTarget(entries[0][0])?.label || "‚Äî";
      }

      const medal = series.correct === series.size ? " üèÖ 100%" : "";
      const msg = most !== "‚Äî"
        ? `–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ ${series.correct}/${series.size}${medal}. –ß–∞—â–µ –æ—à–∏–±–∫–∏: ${most}.`
        : `–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ ${series.correct}/${series.size}${medal}.`;

      setMessage(msg, "ok");

      updateMeta();
      setRepeatButtonVisibility();
      persist(true);
    }
  };

  const nextTask = () => {
    if (!current) { newTask(); return; }

    finishTaskTimer();
    updateMeta();

    if (series.active) {
      series.index += 1;
      if (current.solved) series.correct += 1;

      // —Ñ–∏–∫—Å–∏—Ä—É–µ–º –æ—à–∏–±–æ—á–Ω—ã–µ/—Å–ª–∞–±—ã–µ –º–µ—Å—Ç–∞
      if (!current.solved || current.hadMistake) {
        addMistake(current.targetId, true);
        // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ repeatPool —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—ã–ª–∞ –æ—à–∏–±–∫–∞
        repeatPool.push(snapshotForRepeat(current));
      }

      updateSeriesUI();
      finishSeriesIfNeeded();

      if (!series.active) {
        // –æ—Å—Ç–∞–Ω–æ–≤–∏–º—Å—è
        current = null;
        el.taskText.textContent = "–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞–∂–º–∏ ¬´–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ—à–∏–±–∫–∏¬ª –∏–ª–∏ –Ω–∞—á–Ω–∏ –Ω–æ–≤—É—é —Å–µ—Ä–∏—é.";
        el.answerInput.value = "";
        el.answerInput.blur();
        el.guide.hidden = true;
        el.solutionBox.style.display = "none";
        el.solutionBox.innerHTML = "";
        persist(false);
        return;
      }
    }

    newTask();
  };

  const resetProgress = () => {
    const ok = confirm("–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —ç—Ç–æ–≥–æ —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞?");
    if (!ok) return;

    stats = { solved: 0, correct: 0, streak: 0 };
    series = { active: false, size: 10, index: 0, correct: 0, mode: "normal" };
    current = null;

    timeSumMs = 0; timeCount = 0; taskStartMs = null;
    mistakesByTarget = {}; mistakesThisSeries = {};
    sessions = [];
    repeatPool = []; repeatQueue = [];
    recentKeys = [];

    updateStatsUI();
    updateSeriesUI();
    updateMeta();
    setRepeatButtonVisibility();

    el.taskText.textContent = "–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω. –ù–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä¬ª –∏–ª–∏ –Ω–∞—á–Ω–∏ —Å–µ—Ä–∏—é.";
    el.answerInput.value = "";
    el.guide.hidden = true;
    el.message.style.display = "none";
    el.solutionBox.style.display = "none";
    el.solutionBox.innerHTML = "";

    if (storage) { try { storage.removeItem(STORAGE_KEY); } catch {} }
  };

  // ===== events =====
  el.newBtn.addEventListener("click", () => { newTask(); persist(true); });

  el.startSeriesBtn.addEventListener("click", startSeries);
  el.stopSeriesBtn.addEventListener("click", stopSeries);
  el.repeatErrorsBtn.addEventListener("click", startRepeatErrors);

  el.checkBtn.addEventListener("click", checkAnswer);
  el.nextBtn.addEventListener("click", nextTask);

  el.answerInput.addEventListener("keydown", (e) => { if (e.key === "Enter") checkAnswer(); });

  el.hintBtn.addEventListener("click", () => { if (current) setMessage(hintText(), "info"); });

  el.solutionBtn.addEventListener("click", () => {
    if (!current) return;
    if (el.solutionBox.style.display === "none") {
      el.solutionBox.style.display = "block";
      el.solutionBox.innerHTML = solutionHTML();
    } else {
      el.solutionBox.style.display = "none";
      el.solutionBox.innerHTML = "";
    }
  });

  el.resetProgressBtn.addEventListener("click", resetProgress);

  el.targetSelect.addEventListener("change", () => { persist(true); if (current) renderGuide(); });
  el.levelSelect.addEventListener("change", () => { persist(true); });
  el.appliedToggle.addEventListener("change", () => { persist(true); });
  el.taskCount.addEventListener("change", () => { persist(true); });

  // ===== init =====
  fillTargetSelect();
  el.targetSelect.value = "tens";
  restore();
  updateStatsUI();
  updateSeriesUI();
  updateMeta();
  setRepeatButtonVisibility();
})();
</script>
</body>
</html>
